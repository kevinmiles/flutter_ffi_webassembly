"use strict";
/* Copyright 2018 Mozilla Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const util_1 = require("./util");
const config_1 = require("./config");
const zlib_1 = require("./zlib");
const node_fetch_1 = require("node-fetch");
var Language;
(function (Language) {
    Language["C"] = "c";
    Language["Cpp"] = "cpp";
    Language["Wat"] = "wat";
    Language["Wasm"] = "wasm";
    Language["Rust"] = "rust";
    Language["Cretonne"] = "cton";
    Language["x86"] = "x86";
    Language["Json"] = "json";
    Language["JavaScript"] = "javascript";
    Language["TypeScript"] = "typescript";
    Language["Text"] = "text";
})(Language = exports.Language || (exports.Language = {}));
var ServiceTypes;
(function (ServiceTypes) {
    ServiceTypes[ServiceTypes["Rustc"] = 0] = "Rustc";
    ServiceTypes[ServiceTypes["Service"] = 1] = "Service";
})(ServiceTypes = exports.ServiceTypes || (exports.ServiceTypes = {}));
class Service {
    static sendRequestJSON(content, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield config_1.default();
            const url = to === ServiceTypes.Rustc ? config.rustc : config.serviceUrl;
            const response = yield node_fetch_1.default(url, {
                method: "POST",
                body: JSON.stringify(content),
                headers: new node_fetch_1.Headers({ "Content-Type": "application/json" })
            });
            return response.json();
        });
    }
    static sendRequest(content, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield config_1.default();
            const url = to === ServiceTypes.Rustc ? config.rustc : config.serviceUrl;
            const response = yield node_fetch_1.default(url, {
                method: "POST",
                body: content,
                headers: new node_fetch_1.Headers({ "Content-Type": "application/x-www-form-urlencoded" })
            });
            return response.json();
        });
    }
    static compileFile(file, from, to, options = "") {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield Service.compile(file.getData(), from, to, options);
            if (!result.success) {
                throw new Error(result.message);
            }
            let data = util_1.decodeRestrictedBase64ToBytes(result.output);
            if (zlib_1.isZlibData(data)) {
                data = yield zlib_1.decompressZlib(data);
            }
            return data;
        });
    }
    static compile(src, from, to, options = "") {
        return __awaiter(this, void 0, void 0, function* () {
            if ((from === Language.C || from === Language.Cpp) && to === Language.Wasm) {
                const project = {
                    output: "wasm",
                    compress: true,
                    files: [
                        {
                            type: from,
                            name: "file." + from,
                            options,
                            src
                        }
                    ]
                };
                const input = encodeURIComponent(JSON.stringify(project)).replace("%20", "+");
                return this.sendRequest("input=" + input + "&action=build", ServiceTypes.Service);
            }
            else if (from === Language.Wasm && to === Language.x86) {
                const input = encodeURIComponent(base64js.fromByteArray(src));
                return this.sendRequest("input=" + input + "&action=wasm2assembly&options=" + encodeURIComponent(options), ServiceTypes.Service);
            }
            else if (from === Language.Rust && to === Language.Wasm) {
                // TODO: Temporary until we integrate rustc into the service.
                return this.sendRequestJSON({ code: src }, ServiceTypes.Rustc);
            }
        });
    }
    static disassembleWasm(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof wabt === "undefined") {
                yield Service.lazyLoad("lib/libwabt.js");
            }
            const module = wabt.readWasm(buffer, { readDebugNames: true });
            if (true) {
                module.generateNames();
                module.applyNames();
            }
            return module.toText({ foldExprs: false, inlineExport: true });
        });
    }
    static disassembleWasmWithWabt(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield Service.disassembleWasm(file.getData());
            const output = file.parent.newFile(file.name + ".wat", model_1.FileType.Wat);
            output.description = "Disassembled from " + file.name + " using Wabt.";
            output.setData(result);
        });
    }
    static assembleWat(wat) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof wabt === "undefined") {
                yield Service.lazyLoad("lib/libwabt.js");
            }
            const module = wabt.parseWat("test.wat", wat);
            module.resolveNames();
            module.validate();
            const binary = module.toBinary({ log: true, write_debug_names: true });
            return binary.buffer;
        });
    }
    static assembleWatWithWabt(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield Service.assembleWat(file.getData());
            const output = file.parent.newFile(file.name + ".wasm", model_1.FileType.Wasm);
            output.description = "Assembled from " + file.name + " using Wabt.";
            output.setData(result);
        });
    }
    static loadProject(json, project) {
        return __awaiter(this, void 0, void 0, function* () {
            function deserialize(json, basePath) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (Array.isArray(json)) {
                        return Promise.all(json.map((x) => deserialize(x, basePath)));
                    }
                    if (json.children) {
                        const directory = new model_1.Directory(json.name);
                        (yield deserialize(json.children, basePath + "/" + json.name)).forEach((file) => {
                            directory.addFile(file);
                        });
                        return directory;
                    }
                    const file = new model_1.File(json.name, json.type);
                    file.description = json.description;
                    if (json.data) {
                        file.setData(json.data);
                    }
                    else if (json.data === null) {
                        file.setData("");
                    }
                    else {
                        const request = yield node_fetch_1.default(basePath + "/" + json.name);
                        file.setData(yield request.text());
                    }
                    return file;
                });
            }
            project.name = json.name;
            (yield deserialize(json.children, "templates/" + json.directory)).forEach((file) => {
                project.addFile(file);
            });
            return json;
        });
    }
    static lazyLoad(uri) {
        const baseUrl = "https://webassembly.studio/";
        let exports;
        switch (uri) {
            case "lib/libwabt.js":
                exports = ["wabt"];
                break;
            case "lib/showdown.min.js":
                exports = ["showdown"];
                break;
            case "lib/binaryen.js":
                exports = ["Binaryen"];
                break;
            default:
                throw new Error("Unknow lazyLoad uri: " + uri);
        }
        return node_fetch_1.default(baseUrl + uri).then(res => res.text()).then(res => {
            const code = new Function(res +
                '\nreturn [' + exports.join(',') + '];');
            const exportsObjs = code();
            exports.forEach((e, i) => global[e] = exportsObjs[i]);
        });
    }
    static disassembleWasmWithBinaryen(file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof Binaryen === "undefined") {
                yield Service.lazyLoad("lib/binaryen.js");
            }
            const data = file.getData();
            const module = Binaryen.readBinary(data);
            const output = file.parent.newFile(file.name + ".wat", model_1.FileType.Wat);
            output.description = "Disassembled from " + file.name + " using Binaryen.";
            output.setData(module.emitText());
        });
    }
    static convertWasmToAsmWithBinaryen(file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof Binaryen === "undefined") {
                yield Service.lazyLoad("lib/binaryen.js");
            }
            const data = file.getData();
            const module = Binaryen.readBinary(data);
            const result = module.emitAsmjs();
            const output = file.parent.newFile(file.name + ".asm.js", model_1.FileType.JavaScript);
            output.description = "Converted from " + file.name + " using Binaryen.";
            output.setData(result);
        });
    }
    static compileMarkdownToHtml(src) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof showdown === "undefined") {
                yield Service.lazyLoad("lib/showdown.min.js");
            }
            const converter = new showdown.Converter({ tables: true });
            showdown.setFlavor("github");
            return converter.makeHtml(src);
        });
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map