"use strict";
/* Copyright 2018 Mozilla Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const fs_1 = require("fs");
const path_1 = require("path");
let project = new model_1.Project();
let dirsCache = {
    dir: project,
    children: Object.create(null)
};
function stringOrBuffer(content, type) {
    switch (type) {
        case model_1.FileType.Wasm:
        case model_1.FileType.x86:
            return content;
        default:
            return content.toString();
    }
}
function getTypeFromExtension(name) {
    switch (path_1.extname(name)) {
        case ".wasm": return model_1.FileType.Wasm;
        case ".wat": return model_1.FileType.Wat;
        case ".c": return model_1.FileType.C;
        case ".cpp": return model_1.FileType.Cpp;
        case ".rs": return model_1.FileType.Rust;
        default: return model_1.FileType.Unknown;
    }
}
function newFile(path, type, isTransient = false) {
    let p = path.split("/");
    let current = dirsCache;
    let fullname = [];
    while (p.length > 1) {
        const name = p.shift();
        fullname.push(name);
        const entry = current.children[name];
        if (entry) {
            current = entry;
            continue;
        }
        const next = new model_1.Directory(name);
        next.parent = current.dir;
        current = current.children[name] = {
            dir: next,
            children: Object.create(null)
        };
        if (!fs_1.existsSync(fullname.join(path_1.sep))) {
            fs_1.mkdirSync(fullname.join(path_1.sep));
        }
    }
    const [filename] = p;
    fullname.push(filename);
    const ospath = fullname.join(path_1.sep);
    const file = new model_1.File(filename, type);
    file.parent = current.dir;
    fs_1.writeFileSync(ospath, "");
    file.onGetData = () => stringOrBuffer(fs_1.readFileSync(ospath), type);
    file.onSetData = (data) => fs_1.writeFileSync(ospath, data);
    return file;
}
exports.newFile = newFile;
function getFile(path) {
    let p = path.split("/");
    let current = dirsCache;
    let fullname = [];
    while (p.length > 1) {
        const name = p.shift();
        fullname.push(name);
        const entry = current.children[name];
        if (entry) {
            current = entry;
            continue;
        }
        if (!fs_1.existsSync(fullname.join(path_1.sep))) {
            return null;
        }
        const next = new model_1.Directory(name);
        next.parent = current.dir;
        current = current.children[name] = {
            dir: next,
            children: Object.create(null)
        };
    }
    const [filename] = p;
    fullname.push(filename);
    const ospath = fullname.join(path_1.sep);
    if (!fs_1.existsSync(ospath)) {
        return null;
    }
    const type = getTypeFromExtension(filename);
    const file = new model_1.File(filename, type);
    file.parent = current.dir;
    file.onGetData = () => stringOrBuffer(fs_1.readFileSync(ospath), type);
    file.onSetData = (data) => fs_1.writeFileSync(ospath, data);
    return file;
}
exports.getFile = getFile;
//# sourceMappingURL=project.js.map